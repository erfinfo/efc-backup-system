#!/usr/bin/env node

/**
 * Script de configuration initiale pour EFC Backup System
 * - Cr√©ation des dossiers n√©cessaires
 * - Initialisation de la base de donn√©es
 * - Cr√©ation de l'utilisateur admin par d√©faut
 * - V√©rification de la configuration
 * - Tests de connectivit√©
 */

const path = require('path');
const fs = require('fs').promises;
const readline = require('readline');
const crypto = require('crypto');
const bcrypt = require('bcrypt');
const { initDatabase, createUser, db } = require('../src/utils/database');
const { logger } = require('../src/utils/logger');

// Configuration
const DEFAULT_ADMIN_USERNAME = 'admin';
const DEFAULT_ADMIN_EMAIL = 'admin@efc-backup.local';

class SetupManager {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });
    }

    async prompt(question) {
        return new Promise((resolve) => {
            this.rl.question(question, (answer) => {
                resolve(answer);
            });
        });
    }

    async promptPassword(question) {
        return new Promise((resolve) => {
            const stdin = process.stdin;
            const stdout = process.stdout;
            
            stdin.on('data', (char) => {
                char = char.toString('utf8');
                switch (char) {
                    case '\n':
                    case '\r':
                    case '\u0004':
                        stdin.pause();
                        break;
                    default:
                        stdout.clearLine();
                        stdout.cursorTo(0);
                        stdout.write(question + Array(stdin.line.length + 1).join('*'));
                        break;
                }
            });
            
            this.rl.question(question, (answer) => {
                resolve(answer);
            });
        });
    }

    /**
     * Cr√©er les dossiers n√©cessaires
     */
    async createDirectories() {
        console.log('\nüìÅ Cr√©ation des dossiers n√©cessaires...');
        
        const directories = [
            process.env.BACKUP_PATH || '/backup',
            process.env.LOG_PATH || './logs',
            './data',
            './temp',
            './config'
        ];
        
        for (const dir of directories) {
            try {
                await fs.mkdir(dir, { recursive: true });
                console.log(`‚úÖ Dossier cr√©√©/v√©rifi√©: ${dir}`);
            } catch (error) {
                console.error(`‚ùå Erreur lors de la cr√©ation de ${dir}:`, error.message);
            }
        }
    }

    /**
     * Initialiser la base de donn√©es
     */
    async initializeDatabase() {
        console.log('\nüóÑÔ∏è  Initialisation de la base de donn√©es...');
        
        try {
            await initDatabase();
            console.log('‚úÖ Base de donn√©es initialis√©e avec succ√®s');
            
            // V√©rifier les tables
            const tables = await db.all(
                "SELECT name FROM sqlite_master WHERE type='table'"
            );
            console.log(`‚úÖ ${tables.length} tables cr√©√©es`);
            
        } catch (error) {
            console.error('‚ùå Erreur lors de l\'initialisation de la base:', error);
            throw error;
        }
    }

    /**
     * Cr√©er l'utilisateur admin par d√©faut
     */
    async createAdminUser() {
        console.log('\nüë§ Configuration de l\'utilisateur administrateur...');
        
        try {
            // V√©rifier si un admin existe d√©j√†
            const existingAdmin = await db.get(
                'SELECT * FROM users WHERE role = ? LIMIT 1',
                ['admin']
            );
            
            if (existingAdmin) {
                console.log('‚ÑπÔ∏è  Un utilisateur admin existe d√©j√†');
                const reset = await this.prompt('Voulez-vous r√©initialiser le mot de passe admin? (o/n): ');
                
                if (reset.toLowerCase() !== 'o') {
                    return;
                }
            }
            
            // Demander les informations
            const username = await this.prompt(`Nom d'utilisateur admin [${DEFAULT_ADMIN_USERNAME}]: `) || DEFAULT_ADMIN_USERNAME;
            const email = await this.prompt(`Email admin [${DEFAULT_ADMIN_EMAIL}]: `) || DEFAULT_ADMIN_EMAIL;
            
            let password;
            let confirmPassword;
            
            do {
                password = await this.prompt('Mot de passe admin (min 8 caract√®res): ');
                
                if (password.length < 8) {
                    console.log('‚ùå Le mot de passe doit contenir au moins 8 caract√®res');
                    continue;
                }
                
                confirmPassword = await this.prompt('Confirmer le mot de passe: ');
                
                if (password !== confirmPassword) {
                    console.log('‚ùå Les mots de passe ne correspondent pas');
                }
            } while (password.length < 8 || password !== confirmPassword);
            
            // Hasher le mot de passe
            const hashedPassword = await bcrypt.hash(password, 12);
            
            if (existingAdmin) {
                // Mettre √† jour l'admin existant
                await db.run(
                    'UPDATE users SET username = ?, email = ?, password = ? WHERE id = ?',
                    [username, email, hashedPassword, existingAdmin.id]
                );
                console.log('‚úÖ Mot de passe admin r√©initialis√©');
            } else {
                // Cr√©er le nouvel admin
                await createUser({
                    username,
                    email,
                    password: hashedPassword,
                    role: 'admin',
                    active: true,
                    permissions: JSON.stringify({
                        all: true
                    })
                });
                console.log('‚úÖ Utilisateur admin cr√©√© avec succ√®s');
            }
            
            console.log('\nüìã Informations de connexion:');
            console.log(`   Utilisateur: ${username}`);
            console.log(`   Email: ${email}`);
            console.log('   Mot de passe: [celui que vous avez d√©fini]');
            
        } catch (error) {
            console.error('‚ùå Erreur lors de la cr√©ation de l\'admin:', error);
            throw error;
        }
    }

    /**
     * V√©rifier et cr√©er le fichier .env
     */
    async checkEnvironment() {
        console.log('\n‚öôÔ∏è  V√©rification de la configuration...');
        
        const envPath = path.join(process.cwd(), '.env');
        
        try {
            await fs.access(envPath);
            console.log('‚úÖ Fichier .env trouv√©');
        } catch {
            console.log('‚ö†Ô∏è  Fichier .env non trouv√©, cr√©ation...');
            
            // G√©n√©rer des secrets
            const jwtSecret = crypto.randomBytes(32).toString('hex');
            const sessionSecret = crypto.randomBytes(32).toString('hex');
            
            const envContent = `# Configuration EFC Backup System
NODE_ENV=production
PORT=3000
HOST=0.0.0.0

# Base de donn√©es
DB_PATH=./data/efc-backup.db

# Chemins
BACKUP_PATH=/backup
LOG_PATH=./logs

# S√©curit√©
JWT_SECRET=${jwtSecret}
SESSION_SECRET=${sessionSecret}
PASSWORD_SALT_ROUNDS=12

# Backup
MAX_PARALLEL_BACKUPS=2
RETENTION_DAYS=30
USE_VSS=true

# Logs
LOG_LEVEL=info
LOG_MAX_FILES=10
LOG_MAX_SIZE=100MB

# Monitoring
HEALTH_CHECK_INTERVAL=30000
METRICS_RETENTION_DAYS=30

# Alertes
ALERT_CPU_USAGE_PERCENT=80
ALERT_MEMORY_USAGE_PERCENT=85
ALERT_DISK_USAGE_PERCENT=80

# Notifications (√† configurer)
SMTP_ENABLED=false
NOTIFICATION_EMAIL=
SMTP_HOST=
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=
SMTP_PASS=
`;
            
            await fs.writeFile(envPath, envContent);
            console.log('‚úÖ Fichier .env cr√©√© avec des valeurs par d√©faut');
            console.log('‚ö†Ô∏è  IMPORTANT: Configurez les param√®tres SMTP pour les notifications');
        }
    }

    /**
     * V√©rifier les d√©pendances syst√®me
     */
    async checkSystemDependencies() {
        console.log('\nüîç V√©rification des d√©pendances syst√®me...');
        
        const dependencies = {
            'node': 'node --version',
            'npm': 'npm --version',
            'git': 'git --version'
        };
        
        for (const [name, command] of Object.entries(dependencies)) {
            try {
                const { exec } = require('child_process');
                await new Promise((resolve, reject) => {
                    exec(command, (error, stdout) => {
                        if (error) reject(error);
                        else resolve(stdout);
                    });
                });
                console.log(`‚úÖ ${name} install√©`);
            } catch {
                console.log(`‚ö†Ô∏è  ${name} non trouv√© ou non accessible`);
            }
        }
    }

    /**
     * Tests de connectivit√© r√©seau
     */
    async testNetworkConnectivity() {
        console.log('\nüåê Test de connectivit√© r√©seau...');
        
        const { exec } = require('child_process');
        
        // Test de r√©solution DNS
        try {
            await new Promise((resolve, reject) => {
                exec('nslookup google.com', (error) => {
                    if (error) reject(error);
                    else resolve();
                });
            });
            console.log('‚úÖ R√©solution DNS fonctionnelle');
        } catch {
            console.log('‚ö†Ô∏è  Probl√®me de r√©solution DNS d√©tect√©');
        }
        
        // Test de connectivit√© Internet
        try {
            await new Promise((resolve, reject) => {
                exec('ping -c 1 8.8.8.8', (error) => {
                    if (error) reject(error);
                    else resolve();
                });
            });
            console.log('‚úÖ Connectivit√© Internet OK');
        } catch {
            console.log('‚ö†Ô∏è  Pas de connectivit√© Internet d√©tect√©e');
        }
    }

    /**
     * Afficher le r√©sum√© de l'installation
     */
    displaySummary() {
        console.log('\n' + '='.repeat(50));
        console.log('üéâ Configuration EFC Backup System termin√©e!');
        console.log('='.repeat(50));
        console.log('\nüìù Prochaines √©tapes:');
        console.log('1. Configurez les param√®tres SMTP dans .env pour les notifications');
        console.log('2. Ajoutez des clients via l\'interface web');
        console.log('3. Configurez les planifications de backup');
        console.log('\nüöÄ Pour d√©marrer le serveur:');
        console.log('   npm start');
        console.log('\nüåê L\'interface sera accessible sur:');
        console.log('   http://localhost:3000');
        console.log('\nüìö Documentation:');
        console.log('   https://github.com/erfinfo/efc-backup-system');
    }

    /**
     * Ex√©cuter la configuration compl√®te
     */
    async run() {
        try {
            console.log('');
            console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
            console.log('‚ïë     EFC Backup System - Setup Wizard        ‚ïë');
            console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
            
            // √âtapes de configuration
            await this.createDirectories();
            await this.checkEnvironment();
            await this.initializeDatabase();
            await this.createAdminUser();
            await this.checkSystemDependencies();
            await this.testNetworkConnectivity();
            
            // Afficher le r√©sum√©
            this.displaySummary();
            
            this.rl.close();
            process.exit(0);
            
        } catch (error) {
            console.error('\n‚ùå Erreur fatale lors de la configuration:', error);
            this.rl.close();
            process.exit(1);
        }
    }
}

// Ex√©cution si appel√© directement
if (require.main === module) {
    const setup = new SetupManager();
    setup.run();
}

module.exports = SetupManager;